<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Studnet Ahmed Albarqi (aa5550)">
<meta name="dcterms.date" content="2025-12-28">

<title>Report “Vector Autoregressive (VAR) Modeling for Shelter Population &amp; Median rent asked in NYC” – Ahmed Albarqi</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-99258d85ffddbd9841977770f8edb96b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../assets/css/styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Ahmed Albarqi</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../projects.html"> 
<span class="menu-text">Research &amp; Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../visualizations.html"> 
<span class="menu-text">Visualizations</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/asbarqi"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/asbarqi/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../assets/files/Ahmed_Albarqi_CV.pdf"> <i class="bi bi-file-earmark-person" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content column-page" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Report “Vector Autoregressive (VAR) Modeling for Shelter Population &amp; Median rent asked in NYC”</h1>
</div>



<div class="quarto-title-meta column-page">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p> </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 28, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introdution" class="level1">
<h1>Introdution</h1>
<p>Homelessness is one of New York City’s most persistent and structurally complex policy challenges. It has remained a central issue for successive governors, mayors, and political leaders, reflecting deep-rooted pressures in the city’s housing market and social safety net. Public discourse and empirical research have consistently linked homelessness to housing affordability, particularly rising rents, with higher rental costs often associated with increases in the number of individuals relying on shelter systems. Understanding the dynamic relationship between rental prices and shelter population is therefore critical for policymakers seeking to design effective housing and homelessness interventions.</p>
<p>This report conducts a detailed time-series analysis using a Vector Autoregressive (VAR) framework to examine the relationship between the monthly average shelter population and the median asking rent in New York City over the period from March 2021 to October 2025. The analysis explores how these two variables co-evolve over time and interact through their respective lag structures. In addition, the estimated model is used to generate forecasts for both variables over a 12-month horizon, from November 2025 to October 2026, providing insight into potential future trends in housing affordability and shelter demand.</p>
</section>
<section id="data-sources-and-description" class="level1">
<h1>Data Sources and Description</h1>
<p>The analysis relies on two primary variables: the monthly average number of individuals in homeless shelters and the median asking rent in New York City. While rental data are reported at a monthly frequency, the shelter population data are originally available on a daily basis. To ensure consistency across series, the daily shelter counts were aggregated to monthly averages.</p>
<section id="individuals-in-shelters" class="level2">
<h2 class="anchored" data-anchor-id="individuals-in-shelters">Individuals in Shelters</h2>
<ul>
<li><p><strong>Definition:</strong> Daily numbers of individuals &amp; families living in Department of Homeless Services (DHS) shelters.</p></li>
<li><p><strong>Source:</strong> https://catalog.data.gov/dataset/dhs-daily-report</p></li>
</ul>
<p>the data has been aggregated to a monthly average level</p>
</section>
<section id="median-rent-asked" class="level2">
<h2 class="anchored" data-anchor-id="median-rent-asked">Median Rent Asked</h2>
<ul>
<li><p><strong>Definition:</strong> The exact monthly median rent asked among all rental listings available on StreetEasy at any point during the month/quarter/year.</p></li>
<li><p><strong>Source:</strong> https://tinyurl.com/yysmzxca</p></li>
</ul>
</section>
</section>
<section id="methodology" class="level1">
<h1>Methodology</h1>
<p>This section outlines the econometric framework used to estimate the VAR model and the diagnostic tests conducted to validate its assumptions. The objective is to model the growth rates of shelter population and median rent as functions of their own lagged values and the lagged values of the other variable.</p>
<p>Formally, the VAR system is specified as:</p>
<p><span class="math display">\[
Y_{1,t}
= \alpha_1
+ \sum_{i=1}^{p} \beta_{11,i} \, Y_{1,t-i}
+ \sum_{i=1}^{p} \beta_{12,i} \, Y_{2,t-i}
+ \varepsilon_{1,t}
\]</span></p>
<p><span class="math display">\[
Y_{2,t}
= \alpha_2
+ \sum_{i=1}^{p} \beta_{21,i} \, Y_{1,t-i}
+ \sum_{i=1}^{p} \beta_{22,i} \, Y_{2,t-i}
+ \varepsilon_{2,t}
\]</span> Where,</p>
<p><span class="math display">\[
Y_{1,t} = \Delta \ln(\text{Shelter Population}_t)
\]</span></p>
<p><span class="math display">\[
Y_{2,t} = \Delta \ln(\text{Median Rent}_t)
\]</span></p>
<section id="stationarity-test" class="level2">
<h2 class="anchored" data-anchor-id="stationarity-test">Stationarity Test</h2>
<p>Stationarity is a prerequisite for valid VAR estimation and forecasting. Time series that exhibit trends or unit roots can lead to spurious regression results if modeled in levels.</p>
<p>Visual inspection of the level series <strong>Figure 1 in the Appendix</strong> indicates that both the monthly average shelter population and the median asking rent display trending behavior. Consistent with this observation, Augmented Dickey–Fuller (ADF) test results reported in <strong>Table 1</strong> fail to reject the null hypothesis of a unit root for both series.</p>
<p>Applying logarithmic transformations does not resolve the non-stationarity. As shown in <strong>Figure 2</strong> and confirmed by the ADF results in <strong>Table 2</strong>, the log-transformed series remain non-stationary.</p>
<p>However, taking first differences of the logarithmic series yields stationary processes. <strong>Figure 3</strong> demonstrates stable behavior for both differenced series, and the ADF test results in <strong>Table 3</strong> reject the null hypothesis of non-stationarity at conventional significance levels. Consequently, both variables are treated as integrated of order one, I(1), and the VAR model is estimated using first differences of the log-transformed series.</p>
</section>
<section id="cointegration" class="level2">
<h2 class="anchored" data-anchor-id="cointegration">Cointegration</h2>
<p>When multiple series are I(1), it is necessary to test for cointegration to determine whether a long-run equilibrium relationship exists. If such a relationship is present, a Vector Error Correction Model (VECM) would be more appropriate than a VAR in differences.</p>
<p>Johansen’s cointegration test was conducted using the log-level series. As reported in <strong>Table 4</strong>, the test statistic for the null hypothesis of no cointegration (r = 0) is 8.26, which is below the 5 percent critical value of 15.67. Therefore, the null hypothesis cannot be rejected, indicating no evidence of a stable long-run relationship between shelter population and median rent.</p>
<p>Given the absence of cointegration, a VAR model in first differences is appropriate, and a VECM specification is not warranted.</p>
</section>
</section>
<section id="var-model" class="level1">
<h1>VAR Model</h1>
<p>Since both series are I(1) and not cointegrated, a VAR model is estimated using the first differences of their logarithms. This specification captures short-run dynamics and interdependencies without imposing long-run equilibrium restrictions.</p>
<section id="lags-specifications" class="level2">
<h2 class="anchored" data-anchor-id="lags-specifications">Lags specifications</h2>
<p>Optimal lag length was determined using information criteria, including AIC, SC, and HQ, as shown in <strong>Table 5</strong>. Based on the majority of criteria, the selected lag order is <strong>VAR(4)</strong>.</p>
</section>
<section id="model-specifications" class="level2">
<h2 class="anchored" data-anchor-id="model-specifications">Model Specifications</h2>
<p>The VAR(4) model was estimated with a constant term. Full regression results are reported in <strong>Table 6</strong> of the Appendix. The estimated equations are summarized below:</p>
<p><span class="math display">\[
\begin{aligned}
\Delta \ln(\text{Shelter})_t =\;&amp;
0.5490\,\Delta \ln(\text{Shelter})_{t-1}
+ 0.0047\,\Delta \ln(\text{Rent})_{t-1}
- 0.2178\,\Delta \ln(\text{Shelter})_{t-2}
- 0.0881\,\Delta \ln(\text{Rent})_{t-2} \\
&amp;+ 0.2254\,\Delta \ln(\text{Shelter})_{t-3}
+ 0.4075\,\Delta \ln(\text{Rent})_{t-3}
+ 0.1553\,\Delta \ln(\text{Shelter})_{t-4}
+ 0.2424\,\Delta \ln(\text{Rent})_{t-4} \\
&amp;- 0.00066.
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\Delta \ln(\text{Rent})_t =\;&amp;
-0.0054\,\Delta \ln(\text{Shelter})_{t-1}
+ 0.4296\,\Delta \ln(\text{Rent})_{t-1}
- 0.2940\,\Delta \ln(\text{Shelter})_{t-2}
+ 0.3031\,\Delta \ln(\text{Rent})_{t-2} \\
&amp;+ 0.5483\,\Delta \ln(\text{Shelter})_{t-3}
- 0.0647\,\Delta \ln(\text{Rent})_{t-3}
- 0.2996\,\Delta \ln(\text{Shelter})_{t-4}
- 0.2730\,\Delta \ln(\text{Rent})_{t-4} \\
&amp;+ 0.00479.
\end{aligned}
\]</span></p>
</section>
</section>
<section id="model-evaluation" class="level1">
<h1>Model Evaluation</h1>
<p>To assess model validity and robustness, several diagnostic tests were conducted, focusing on residual behavior and autocorrelation.</p>
<section id="residual-plot" class="level2">
<h2 class="anchored" data-anchor-id="residual-plot">Residual Plot</h2>
<p>Visual inspection of the residual plots <strong>Figure 3</strong> suggests no systematic patterns, indicating the absence of heteroskedasticity or remaining serial correlation.</p>
</section>
<section id="portmanteau-test-for-autocorrelation" class="level2">
<h2 class="anchored" data-anchor-id="portmanteau-test-for-autocorrelation">Portmanteau-test for Autocorrelation</h2>
<p>The Portmanteau test was applied to formally test for residual autocorrelation. As reported in <strong>Table 6</strong>, the test yields a p-value of <strong>0.58</strong>, which is greater than 0.05. Consequently, we fail to reject the null hypothesis of no serial correlation, supporting the adequacy of the model specification.</p>
</section>
<section id="autocorrelation-function-acf-partiall-autocorrelation-function-pacf" class="level2">
<h2 class="anchored" data-anchor-id="autocorrelation-function-acf-partiall-autocorrelation-function-pacf">Autocorrelation Function (ACF) &amp; Partiall Autocorrelation Function (PACF)</h2>
<p>Further confirmation is provided by the ACF and PACF plots <strong>Figure 4</strong>, where all autocorrelation coefficients lie within the 95 percent confidence bounds. These results indicate that the residuals behave as white noise.</p>
</section>
</section>
<section id="impulse-response-functions-irf" class="level1">
<h1>Impulse Response Functions (IRF)</h1>
<p>Impulse response functions illustrate how a one-time shock to one variable affects the current and future values of both variables in the system.</p>
<section id="shelter-impulse-response-functions-irf" class="level2">
<h2 class="anchored" data-anchor-id="shelter-impulse-response-functions-irf">Shelter Impulse Response Functions (IRF)</h2>
<p><strong>Figure 5</strong> shows that a 1 percent shock to shelter population growth has a persistent effect on itself, lasting approximately nine months and peaking in the fourth month after the shock. The same shock exerts a smaller and shorter-lived effect on rent growth, lasting around four months, with an initial positive response followed by a brief negative adjustment.</p>
</section>
<section id="rent-impulse-response-functions-irf" class="level2">
<h2 class="anchored" data-anchor-id="rent-impulse-response-functions-irf">Rent Impulse Response Functions (IRF)</h2>
<p><strong>Figure 6</strong> indicates that a 1 percent shock to median rent growth generates a delayed but positive response in shelter population growth, beginning in the second month and persisting for up to nine months, with the largest effect occurring in the fourth month. The impact on rent growth itself declines over time, turning negative after the fourth month and persisting for roughly ten periods.</p>
</section>
</section>
<section id="granger-causality" class="level1">
<h1>Granger Causality</h1>
<p>Granger causality tests were conducted to examine whether lagged values of one variable improve the prediction of the other.</p>
<p>Results reported in <strong>Table 7</strong> show that changes in median rent Granger-cause changes in shelter population, with a p-value of <strong>0</strong>. Similarly, changes in shelter population Granger-cause changes in median rent, with a p-value of <strong>0.01</strong>.</p>
<p>These findings indicate bilateral (feedback) Granger causality, suggesting that both variables contain predictive information about each other’s future movements.</p>
</section>
<section id="forecasting" class="level1">
<h1>Forecasting</h1>
<p>Using the estimated VAR(4) model, 12-month-ahead forecasts were generated for both variables. <strong>Figure 7</strong> presents forecasts of percentage changes, which were subsequently transformed back into levels for interpretability.</p>
<p><strong>Table 8</strong> reports the forecasted values for both growth rates and levels, while <strong>Figures 8 and 9</strong> compare historical data with projected paths for shelter population and median rent. These forecasts provide insight into expected short-run dynamics in housing affordability and shelter demand, conditional on historical relationships.</p>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>This report developed and evaluated a VAR(4) model to analyze the dynamic relationship between monthly average shelter population and median asking rent in New York City. Using data from the Department of Homeless Services and StreetEasy, the analysis carefully addressed stationarity, cointegration, and model specification to avoid spurious inference. Diagnostic tests confirmed that the estimated model is well specified and free from residual autocorrelation.</p>
<p>The results reveal strong short-run interactions between rent growth and shelter population growth, including evidence of bilateral Granger causality. Impulse response analysis highlights the persistence and timing of shocks across variables, while the forecasts provide forward-looking insights into potential trends over the next year.</p>
<p>Overall, the findings underscore the tight and dynamic linkage between housing affordability and homelessness in New York City, reinforcing the importance of coordinated housing and social policy interventions to address shelter demand and housing market pressures simultaneously.</p>
<div style="page-break-after: always;"></div>
</section>
<section id="appendix" class="level1">
<h1>Appendix</h1>
<section id="figures-tables" class="level2">
<h2 class="anchored" data-anchor-id="figures-tables">Figures &amp; Tables</h2>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="rent_shelter_var_files/figure-html/shelter-rent-subfigures-1.png" style="width:100.0%;height:40.0%" class="figure-img"></p>
<figcaption>Shelter Population</figcaption>
</figure>
</div>
</div>
<p>Shelter Population and Median Rent Over Time</p>
</div>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="rent_shelter_var_files/figure-html/shelter-rent-growth-subfigures-1.png" style="width:100.0%;height:40.0%" class="figure-img"></p>
<figcaption>Growth Rate of Shelter Population</figcaption>
</figure>
</div>
</div>
<p>Growth Rates of Shelter Population and Median Rent</p>
</div>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="rent_shelter_var_files/figure-html/shelter-rent-resid-subfigures-1.png" style="width:100.0%;height:40.0%" class="figure-img"></p>
<figcaption>Change in Shelter (Percentage Change)</figcaption>
</figure>
</div>
</div>
<p>Residuals Plots of VAR(4) Model</p>
</div>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="rent_shelter_var_files/figure-html/acf-pacf-residuals-1.png" style="width:100.0%;height:80.0%" class="figure-img"></p>
<figcaption>ACF: Shelter</figcaption>
</figure>
</div>
</div>
<p>ACF and PACF of Residuals for Shelter and Rent</p>
</div>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="rent_shelter_var_files/figure-html/irf-plot-1.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Impulse Response Functions from VAR(4)</figcaption>
</figure>
</div>
</div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="rent_shelter_var_files/figure-html/irf-plot-2.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Impulse Response Functions from VAR(4)</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="rent_shelter_var_files/figure-html/var-forecast-subfigures-1.png" style="width:100.0%;height:45.0%" class="figure-img"></p>
<figcaption>Forecast of dln(Shelter)</figcaption>
</figure>
</div>
</div>
<p>12-Month Forecasts from the VAR(4) Model</p>
</div>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="rent_shelter_var_files/figure-html/forecast-1.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Forecasting</figcaption>
</figure>
</div>
</div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="rent_shelter_var_files/figure-html/forecast-2.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Forecasting</figcaption>
</figure>
</div>
</div>
</div>
<div style="page-break-after: always;"></div>
<div style="page-break-after: always;"></div>
<div class="cell">
<div class="cell-output-display">

</div>
</div>
<div class="cell">
<div class="cell-output-display">

</div>
</div>
<div class="cell">
<div class="cell-output-display">

</div>
</div>
<div class="cell">
<div class="cell-output-display">

</div>
</div>
<div class="cell">
<div class="cell-output-display">

</div>
</div>
<div class="cell">
<div class="cell-output-display">

</div>
</div>
<div class="cell">
<div class="cell-output-display">

</div>
</div>
<div class="cell">
<div class="cell-output-display">

</div>
</div>
<div class="cell">
<div class="cell-output-display">

</div>
</div>


</section>
</section>

</main> <!-- /main -->
document.addEventListener("DOMContentLoaded", () =&gt; {
  const el = document.getElementById("typed-role");
  if (!el) return;

  const phrases = [
    "Policy Research",
    "Computational Social Science",
    "Applied Research"
  ];

  let p = 0, i = 0;
  let deleting = false;

  function tick() {
    const current = phrases[p];
    const text = deleting ? current.slice(0, i--) : current.slice(0, i++);

    el.textContent = text;

    let delay = deleting ? 40 : 70;
    if (!deleting &amp;&amp; i === current.length + 1) {
      delay = 900;
      deleting = true;
      i = current.length;
    } else if (deleting &amp;&amp; i &lt; 0) {
      deleting = false;
      p = (p + 1) % phrases.length;
      i = 0;
      delay = 250;
    }

    setTimeout(tick, delay);
  }

  tick();
});
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>