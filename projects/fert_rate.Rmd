---
title: ' Report \break "Fertility Rate Forecasting for Saudi Arabia" '
author: Ahmed Albarqi  
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_depth: 3
    toc_float: yes
    number_sections: yes
    highlight: tango
    theme: default
    fig_caption: yes
    df_print: tibble
  pdf_document:
    toc: no
    latex_engine: xelatex
    toc_depth: '3'
    number_sections: yes
urlcolor: blue
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(kableExtra)
library(dynlm)
library(modelsummary)
library(ggplot2)
library(broom)
library(lmtest)
library(knitr)
library(MuMIn)
library(tseries)
library(forecast)
library(urca)
library(aTSA)
library(FinTS) 
load("project1_data.RData")
```
# Introduction

Over the past six decades, Saudi Arabia has undergone one of the most rapid fertility transitions in the world. In the 1960s, the fertility rate was nearly eight children per woman, largely driven by the country’s conservative and religious social structure. In contrast, recent decades have seen a dramatic decline, with fertility rates falling to around two children per woman. This sharp reduction can be attributed to sweeping socio-economic reforms, including the expansion of women’s education, shifts in female labor market participation, and broader societal transformations under Vision 2030.

This project aims to analyze and forecast Saudi Arabia’s fertility rate using the ARIMA model. By modeling historical trends and projecting future changes, the study seeks to shed light on the potential implications of fertility dynamics for labor market policies and broader social development strategies in Saudi Arabia.

# Definition & Data Source

The Total Fertility Rate (TFR) measures the average number of children a woman would have over her lifetime if she were to experience the current age-specific fertility rates throughout her childbearing years. It is expressed as the number of births per woman in a given year.

For this study, the analysis covers the period 1960–2023, utilizing annual data obtained from the World Bank Open Data platform. The dataset provides consistent and internationally comparable fertility indicators, making it a reliable source for examining long-term demographic trends in Saudi Arabia

# Methodolgy

To drive the forecasting model we will transform the dataset from  fertility rate to growth rate of fertility rate by using this equation:
$$
\text{Growth Rate}_t = \Delta \ln(\text{Fertility Rate}_t)
$$
Additionally, we will conduct differencing to the series with (I=1), to make the series stationary. Finally, we chose AR(4) for this analysis because it passed all the tests. 

# Diagnosing

To start the analysis, Referring to the **Figure 1**, the series seems to have a severe downward trend, and a severe variance as well. This is an indication that the series isn't stationary. 


```{r echo=FALSE, fig.width=4, fig.height=3, fig.align='center'}
Fert_ts <- ts(df_saudi$value, start=1960, frequency = 1) 
plot(Fert_ts, type = "l", col = "blue", lwd = 2,
     main = "Figure 1: Time Series of Fertility rate KSA 1960-2023",
     xlab = "Time", ylab = "Fertility rate")
```


## Data Processing 
To address the non-stationarity observed in the fertility rate series, the variable is transformed from levels to growth rates using a log-difference transformation:

$$
\text{Growth Rate}_t = \Delta \ln(\text{Fertility Rate}_t)
$$

This transformation substantially improves the visual properties of the series by removing the pronounced trend present in the level data as shown in **Figure 2**. However, despite the improved appearance, visual inspection alone is insufficient to establish stationarity. Therefore, formal unit root tests are conducted to assess whether the transformed series is stationary.

```{r echo=FALSE, fig.width=4, fig.height=3, fig.align='center'}
ln_fer <- log(Fert_ts)
growth_rate <- diff(ln_fer)   

plot(growth_rate, main="Figure 2: Growth Rate of Fertility Rate", ylab="% Growth Rate")
```

Both the Augmented Dickey–Fuller (ADF) test and the DF-GLS test are applied. In this report, greater emphasis is placed on the DF-GLS test, as it is generally more powerful than the standard ADF test, particularly in small samples and in the presence of deterministic components.
The results of the DF-GLS test are shown below in **Table 1**:

```{r echo=FALSE, fig.width=4, fig.height=3, fig.align='center'}
# adf_result <- adf.test(growth_rate)
dfgls_result <- ur.ers(growth_rate, type = "DF-GLS", model = "constant", lag.max = 7)
dfgls_stat <- as.numeric(dfgls_result@teststat)
dfgls_table <- data.frame(
  Test = "DF-GLS ",
  Statistic = round(dfgls_stat, 3))

kable(dfgls_table, caption = "Table 1: DF-GLS Stationarity Test")

```

The absolute value of the DF-GLS t-statistic is `r abs(round(dfgls_stat, 3))`, which is smaller than the 5% critical value of 1.96. As a result, the null hypothesis of a unit root cannot be rejected. This indicates that the growth rate of the fertility rate remains non-stationary, even after log-differencing.



## Differncing

To achieve stationarity, further differencing is applied to the growth rate series. Specifically, the first difference of the growth rate is taken (I=1):
```{r echo=FALSE, fig.width=4, fig.height=3, fig.align='center'}
model_diff <- diff(growth_rate)
#model_diff <- diff(model_diff)


plot(model_diff, main="Figure 3: I=1 of Growth Rate of Fertility Rate", ylab="% Growth Rate")
```

The differenced series in **Figure 3** exhibits a substantial improvement in its time-series properties. Visual inspection suggests that the mean is now stable over time, indicating potential stationarity. However, some variability in the variance remains, which may raise concerns about heteroskedasticity and will be addressed in subsequent diagnostics.

To formally assess stationarity, the same unit root testing procedure is applied to the differenced series, focusing again on the DF-GLS test due to its superior power properties. the results of the test is shown in **Table 2**

```{r echo=FALSE, fig.width=4, fig.height=3, fig.align='center'}
##adf.test(model_diff)
dfgls_result <- ur.ers(model_diff, type = "DF-GLS", model = "constant", lag.max = 7)
dfgls_stat <- as.numeric(dfgls_result@teststat)
dfgls_table <- data.frame(
  Test = "DF-GLS ",
  Statistic = round(dfgls_stat, 3))

kable(dfgls_table, caption = "Table 2: DF-GLS Stationarity Test")
```

The absolute value of the DF-GLS t-statistic is `r abs(round(dfgls_stat, 3))` which exceeds the 5% critical value of 1.96. Consequently, the null hypothesis of a unit root is rejected. This provides strong evidence that the differenced growth rate series is stationary.

Thus, after first differencing, the fertility rate series satisfies the stationarity condition required for subsequent time-series modeling.

## ARIMA modeling 

Having established that the series is integrated of order one (I=1) , the next step is to identify the appropriate ARIMA specification by selecting the autoregressive (p), and moving average (q) orders. 

Multiple ARIMA models were estimated and evaluated through an iterative process, including ARIMA(1,1,0), ARIMA(2,1,0), ARIMA(1,1,1), and ARIMA(4,1,0). Model performance was assessed using information criteria (AICc and BIC) as well as residual diagnostics based on the Ljung–Box test.The Ljung–Box test was conducted at lags 8 and 16. The choice of 16 lags follows the standard rule-of-thumb of N/4, where N = 64 in this case.
**Table 3** summarizes the estimated coefficients, information criteria, and Ljung–Box test statistics for each candidate model.

```{r echo=FALSE, fig.width=4, fig.height=3, fig.align='center'}

## AR(1)

ar1 <- arima(growth_rate, order = c(1,1,0), include.mean = FALSE)
coefs1 <- coef(ar1)
se1 <- sqrt(diag(vcov(ar1)))
tvals1 <- coefs1 / se1
BT1_lag8 <- Box.test(ar1$residuals, lag = 8, type = "Ljung-Box", fitdf = 1)
BT1_lag16 <- Box.test(ar1$residuals, lag = 16, type = "Ljung-Box", fitdf = 1)

## ARMA(1,1)

ar11 <- arima(growth_rate, order = c(1,1,1), include.mean = FALSE)
coefs11 <- coef(ar11)
se11 <- sqrt(diag(ar11$var.coef))
tvals11 <- coefs11 / se11
BT11_lag8 <- Box.test(ar11$residuals, lag = 8, type = "Ljung-Box", fitdf = 1)
BT11_lag16 <-Box.test(ar11$residuals, lag = 16, type = "Ljung-Box", fitdf = 1)


## AR2

ar2 <- arima(growth_rate, order = c(2,1,0), include.mean = FALSE)
coefs2 <- coef(ar2)
se2 <- sqrt(diag(ar2$var.coef))
tvals2 <- coefs2 / se2
BT2_lag8 <-Box.test(ar2$residuals, lag = 8, type = "Ljung-Box", fitdf = 2)
BT2_lag16 <-Box.test(ar2$residuals, lag = 16, type = "Ljung-Box", fitdf = 2)

## AR4
ar4 <- arima(growth_rate, order = c(4,1,0), include.mean = FALSE)
coefs4 <- coef(ar4)
se4 <- sqrt(diag(ar4$var.coef))
tvals4 <- coefs4 / se4
BT4_lag8 <-Box.test(ar4$residuals, lag = 8, type = "Ljung-Box", fitdf = 4)
BT4_lag16 <-Box.test(ar4$residuals, lag = 16, type = "Ljung-Box", fitdf = 4)

# Comparison Table
comp_table <- data.frame(
  Model = c("AR(1)", "ARMA(1,1)", "AR(2)", "AR(4)"),
  `Theta1(SE)` = c(
    paste(round(coefs1[1], 3), " (", round(se1[1], 3), ")", sep = ""),
    paste(round(coefs11[1], 3), " (", round(se11[1], 3), ")", sep = ""),
    paste(round(coefs2[1], 3), " (", round(se2[1], 3), ")", sep = ""),
    paste(round(coefs4[1], 3), " (", round(se4[1], 3), ")", sep = "") ),
  
  `Theta2(SE)` = c(
    "N/A",
    "N/A",
    paste(round(coefs2[2], 3), " (", round(se2[2], 3), ")", sep = ""),
    paste(round(coefs4[2], 3), " (", round(se4[2], 3), ")", sep = "") ),
    `Theta3(SE)` = c(
    "N/A",
    "N/A",
    "N/A",
    paste(round(coefs4[3], 3), " (", round(se4[3], 3), ")", sep = "")),`Theta4(SE)` = c(
    "N/A",
    "N/A",
    "N/A",
    paste(round(coefs4[4], 3), " (", round(se4[4], 3), ")", sep = "")),
  
  `Phi1(SE)` = c(
    "N/A",
    paste(round(coefs11[2], 3), " (", round(se11[2], 3), ")", sep = ""),
    "N/A",
    "N/A"),
  
  AICc = c(round(AICc(ar1), 3), round(AICc(ar11), 3), round(AICc(ar2), 3),round(AICc(ar4), 3)),
  BIC  = c(round(BIC(ar1), 3),  round(BIC(ar11), 3),  round(BIC(ar2), 3),round(BIC(ar4), 3)),
  
  `LB8(p-value)`  = c(
    paste(round(BT1_lag8$statistic, 2), " (", round(BT1_lag8$p.value, 5), ")"),
    paste(round(BT11_lag8$statistic, 2), " (", round(BT11_lag8$p.value, 5), ")"),
    paste(round(BT2_lag8$statistic, 2), " (", round(BT2_lag8$p.value, 5), ")"),
    paste(round(BT4_lag8$statistic, 2), " (", round(BT4_lag8$p.value, 5), ")")),
  
  `LB16(p-value)` = c(
    paste0(round(BT1_lag16$statistic, 2), " (", round(BT1_lag16$p.value, 5), ")"),
    paste0(round(BT11_lag16$statistic, 2), " (", round(BT11_lag16$p.value, 5), ")"),
    paste0(round(BT2_lag16$statistic, 2), " (", round(BT2_lag16$p.value, 5), ")"),
    paste0(round(BT4_lag16$statistic, 2), " (", round(BT4_lag16$p.value, 5), ")")))

# To show it vertically because horizontally is hard to compare (my preference)
comp_table_t <- as.data.frame(t(comp_table))
colnames(comp_table_t) <- comp_table_t[1, ]  
comp_table_t <- comp_table_t[-1, ]           
kable(comp_table_t, caption = "Table 3: Comparison of ARIMA Models", align = "c")

```

The results indicate the following:

ARIMA(1,1,0):
This model performs well in terms of AICc and BIC. However, the Ljung–Box test rejects the null hypothesis of no residual autocorrelation at both lag lengths, indicating that the residuals do not behave as white noise. As a result, the model is deemed inadequate.

ARIMA(1,1,1):
Despite competitive information criteria values, this model also fails the Ljung–Box test, rejecting the null hypothesis of white-noise residuals. This suggests remaining serial correlation and model misspecification.

ARIMA(2,1,0):
Although this specification improves flexibility relative to the AR(1) model and maintains reasonable AICc and BIC values, it similarly fails the Ljung–Box diagnostic tests, indicating persistent autocorrelation in the residuals.

ARIMA(4,1,0):
This model delivers superior overall performance. It achieves competitive information criteria values while, crucially, failing to reject the null hypothesis of the Ljung–Box test at both lag lengths. This implies that the residuals behave as white noise, satisfying the key assumption of model adequacy.

# AR(4) 

Having selected the ARIMA(4,1,0) specification, the model’s adequacy is assessed through an examination of coefficient properties, residual behavior, and potential violations of key assumptions. The AR(4) specification used throughout the analysis is given by:

\[
\Delta y_t
=
\texttt{`r round(coefs4[1],3)`}\,\Delta y_{t-1}
+
\texttt{`r round(coefs4[2],3)`}\,\Delta y_{t-2}
+
\texttt{`r round(coefs4[3],3)`}\,\Delta y_{t-3}
+
\texttt{`r round(coefs4[4],3)`}\,\Delta y_{t-4}
+
\varepsilon_t
\]


## Coefficients 

As a preliminary diagnostic, the necessary and sufficient conditions for stationarity of the autoregressive component are examined.

-- Sum of Coefficients = `r round(sum(coefs4[1], coefs4[2], coefs4[3], coefs4[4]), 3)` . 

-- Sum of absolute values of Coefficients = `r round(sum(abs(coefs4[1]), abs(coefs4[2]), abs(coefs4[3]), abs(coefs4[4])), 3)`

The sum of coefficients does not violate the necessary condition, while the sum of absolute coefficients exceeds unity, meaning the sufficient condition for stationarity is not satisfied. As expected for higher-order AR processes, these conditions alone are inconclusive and do not provide definitive evidence regarding the stability of the process. Consequently, further diagnostics based on residual behavior are required.

## Residual Plot

The residuals from the AR(4) model fluctuate around a zero mean, indicating that the model successfully captures the conditional mean dynamics. However, visual inspection reveals a noticeable change in variance beginning around the year 2000, suggesting a potential violation of the homoskedasticity assumption.
```{r echo=FALSE, fig.width=4, fig.height=3, fig.align='center'}
##
residuals_ar4 <- residuals(ar4)
plot(residuals_ar4, type = "l", col = "blue", lwd = 2,
     main = "Figure 4: Residuals from AR(4) model",
     ylab = "Residuals", xlab = "Time")
abline(h = 0, col = "red", lty = 2)
```


## ACF & PACF

The autocorrelation and partial autocorrelation functions of the residuals show no statistically significant spikes outside the confidence bounds. This confirms that the AR(4) model adequately removes serial correlation and that the residuals behave as white noise in the mean.

```{r echo=FALSE,fig.height=3, fig.align='center', fig.cap="Figure 5: ACF & PACF of AR4 model"}

par(mfrow = c(1, 2))
acf(residuals_ar4, main = "ACF of Residuals", lwd = 2, col = "blue")
pacf(residuals_ar4, main = "PACF of Residuals", lwd = 2, col = "red")
par(mfrow = c(1, 1)) 

```

## Heteroskedasticity Test

Given the visual evidence of changing variance, Engle’s ARCH LM test is applied to formally assess the presence of conditional heteroskedasticity. A lag length of 10 is chosen as a conservative diagnostic choice given the sample size, with results shown in **Table 4**

```{r echo=FALSE, fig.width=4, fig.height=3, fig.align='center'}
## chosing 10 because it is the safe option 
arch_test <- ArchTest(residuals_ar4, lags = 10)
arch_pval <- data.frame(
  `ARCH LM-test` = formatC(arch_test$p.value, format = "e", digits = 2)
)
row.names(arch_pval) <- c("P-Value")
kable(arch_pval, caption = "Table 4: ARCH LM Test")
```

The ARCH Engle's test statistic has a p-value of `r abs(round(arch_test$p.value, 3))` and it is < 0.05. This rejects the null hypothesis of ARCH effect, and confirming that the series has Heteroskedasticity.

The detection of ARCH effects implies that while the ARIMA(4,1,0) model adequately captures the conditional mean dynamics, it fails to account for time-varying volatility. To obtain efficient and unbiased inference—particularly for volatility dynamics—a GARCH-type specification is required.

That said, the ARIMA model remains informative for short-run forecasting of the conditional mean, especially when volatility dynamics are not the primary object of interest. Subsequent analysis will therefore extend the model by incorporating a GARCH structure to appropriately model the variance process.


# GARCH Extension: Modeling Time-Varying Volatility

The presence of significant ARCH effects in the residuals of the AR(4) model indicates that, while the conditional mean dynamics are well specified, the assumption of constant variance is violated. To account for volatility clustering and time-varying uncertainty, the model is extended by specifying a GARCH process for the conditional variance. Given the sample size (64 observations), a GARCH(1,1) specification is adopted, which is widely used and typically sufficient to capture persistent volatility dynamics.

## Estimate AR(4)–GARCH(1,1)
Building on the previous results, the ARIMA(4,1,0) specification is retained to model the conditional mean dynamics of the series, as it adequately removes serial correlation in the residuals. However, diagnostic evidence indicates the presence of time-varying volatility, motivating an extension of the model to explicitly account for conditional heteroskedasticity.

Accordingly, the model is specified as an AR(4) process in the mean combined with a GARCH(1,1) process for the conditional variance. The estimated variance parameters from the GARCH(1,1) specification are reported in **Table 5**, and the full model is summarized by the mean and variance equations presented below. This framework allows the dynamics of the series to be decomposed into systematic persistence in the mean and persistent volatility in the variance, providing a more complete representation of both the level and uncertainty of the process.

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(rugarch)

# Ensure numeric vector
y <- as.numeric(growth_rate)

# -------------------------------
# Specify AR(4) mean + GARCH(1,1) variance
# -------------------------------
spec_ar4_garch11 <- ugarchspec(
  variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
  mean.model     = list(armaOrder = c(4, 0), include.mean = FALSE),
  distribution.model = "norm"
)

# Fit the model
fit_ar4_garch11 <- ugarchfit(
  spec = spec_ar4_garch11,
  data = y,
  solver = "hybrid"
)

# -------------------------------
# Extract alpha and beta
# -------------------------------
coef_vec <- coef(fit_ar4_garch11)

alpha1 <- coef_vec["alpha1"]
beta1  <- coef_vec["beta1"]
omega  <- coef_vec["omega"]

# Persistence
persistence <- alpha1 + beta1

# Show results
alpha_beta_table <- data.frame(
  Parameter = c("omega", "alpha1", "beta1", "alpha1 + beta1"),
  Estimate  = round(c(omega, alpha1, beta1, persistence), 4)
)

knitr::kable(alpha_beta_table, caption = "Table 5: GARCH(1,1) Variance Parameters")
```

The estimated GARCH(1,1) variance parameters indicate strong and highly persistent volatility dynamics in the series. The ARCH coefficient, \(\alpha_1 =\) `r round(alpha1, 4)`, captures the short-run response of conditional variance to unexpected shocks and suggests that large innovations have a substantial immediate impact on volatility. The GARCH coefficient, \(\beta_1 =\) `r round(beta1, 4)`, reflects persistence in volatility, indicating that periods of elevated uncertainty tend to persist over time.

The sum of the ARCH and GARCH coefficients, \(\alpha_1 + \beta_1 =\) `r round(alpha1 + beta1, 4)`, is extremely close to unity, implying near-integrated volatility dynamics. While the condition \(\alpha_1 + \beta_1 < 1\) technically ensures covariance stationarity of the variance process, the proximity to one suggests that shocks to volatility decay very slowly and have long-lasting effects. This behavior is consistent with pronounced volatility clustering.

The estimated constant term in the variance equation, \(\omega =\) `r round(omega, 6)`, is effectively zero, indicating that the evolution of volatility is largely driven by past shocks and past conditional variance rather than by a fixed long-run variance level.

Overall, these results confirm that extending the AR(4) mean specification with a GARCH(1,1) variance process is necessary to appropriately model time-varying volatility and to obtain reliable inference and forecast uncertainty.

The AR(4)–GARCH(1,1) model is formally specified below through its conditional mean and variance equations.

The mean equation remains the selected AR(4) specification:

\[
\Delta y_t
=
\texttt{`r round(coefs4[1],3)`}\,\Delta y_{t-1}
+
\texttt{`r round(coefs4[2],3)`}\,\Delta y_{t-2}
+
\texttt{`r round(coefs4[3],3)`}\,\Delta y_{t-3}
+
\texttt{`r round(coefs4[4],3)`}\,\Delta y_{t-4}
+
\varepsilon_t
\]

The conditional variance follows a GARCH(1,1) process:

\[
\sigma_t^2
=
0.4338\,\varepsilon_{t-1}^2
+
0.5652\,\sigma_{t-1}^2
\]


## Residual Diagnostics and Model Adequacy

To assess model adequacy, we examine the standardized residuals from the AR(4)–GARCH(1,1) model. **Figure 6** shows that the standardized residuals fluctuate around zero without visible persistence. Also, it indicates no meaningful autocorrelation in the standardized residuals, suggesting that the mean dynamics are adequately captured.

```{r stdres, echo=FALSE, fig.width=6, fig.height=3.2, fig.align='center' }
z <- as.numeric(residuals(fit_ar4_garch11, standardize = TRUE))

plot(z, type = "l", lwd = 1.5,
     main = "Figure 6: Standardized Residuals: AR(4)–GARCH(1,1)",
     ylab = expression(z[t]), xlab = "Time")
abline(h = 0, lty = 2)
```

To formally confirm the absence of serial correlation, Ljung–Box tests are applied to the standardized residuals at lags 8 and 16. The results, reported in **Table 6**, fail to reject the null hypothesis of no autocorrelation at conventional significance levels, confirming that the residuals behave as white noise in the mean.

```{r lbtest, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

lb_8  <- Box.test(z, lag = 8,  type = "Ljung-Box")
lb_16 <- Box.test(z, lag = 16, type = "Ljung-Box")

lb_table <- data.frame(
  Test = c("Ljung–Box (lag 8)", "Ljung–Box (lag 16)"),
  Statistic = round(c(as.numeric(lb_8$statistic),
                      as.numeric(lb_16$statistic)), 3),
  `p-value` = signif(c(as.numeric(lb_8$p.value),
                       as.numeric(lb_16$p.value)), 3)
)

kable(lb_table, caption = "Table 6: Ljung–Box tests on standardized residuals (post-GARCH)")

```
# Forecasting

Having established the adequacy of the AR(4) and AR(4)–GARCH(1,1) specifications, this section presents short-run forecasts of the fertility rate. Forecasts are generated over a 4-period horizon. The AR(4) model provides forecasts based solely on conditional mean dynamics, while the AR(4)–GARCH(1,1) model incorporates time-varying volatility, allowing forecast uncertainty to evolve over time. Comparing these forecasts highlights the role of conditional heteroskedasticity in shaping forecast behavior and uncertainty.


**Figure 7** & **Table 7** compare forecasted fertility rates generated by the AR(4) model and the AR(4)–GARCH(1,1) model over the forecast horizon. Although both models share the same conditional mean structure, their forecasts diverge markedly once projected back into fertility levels.

The AR(4) model predicts a gradual decline in fertility rates, with minor short-run fluctuations. This pattern reflects the persistence captured by the autoregressive structure and extrapolates recent downward dynamics in the growth rate of fertility. Because the AR(4) model assumes constant variance, forecast paths are driven solely by mean dynamics, resulting in relatively smooth and conservative projections.

In contrast, the AR(4)–GARCH(1,1) model produces a steadily increasing fertility path. This divergence arises because the GARCH component captures highly persistent volatility, as evidenced by the near-unit volatility persistence (alpha + beta ≈1). When forecasts are iteratively transformed from growth rates back into fertility levels, periods of elevated conditional variance amplify forecast uncertainty and compound upward movements in the level series. As a result, even small positive expected growth rates translate into increasingly larger fertility projections over time.

Importantly, this difference does not imply that the GARCH model fundamentally predicts higher mean fertility growth. Rather, it highlights how persistent volatility interacts with nonlinear level transformations, causing forecasts to diverge despite identical mean specifications. The AR(4)–GARCH(1,1) model therefore produces more dispersed and dynamic level forecasts, reflecting uncertainty accumulation rather than deterministic trend reversal.

Overall, the comparison underscores that incorporating time-varying volatility can materially affect long-horizon level forecasts, even when point forecasts of the growth rate are similar. This finding emphasizes the importance of accounting for volatility dynamics when forecasting demographic variables that are reconstructed through nonlinear transformations.

```{r level-forecast, echo=FALSE, message=FALSE, warning=FALSE}
library(forecast)
library(rugarch)

h <- 4

# --- AR(4) forecast (growth) ---
fc_ar4 <- forecast::forecast(ar4, lead = h)

# Robust: if fc_ar4 is a list/forecast object use $mean, otherwise use the vector itself
ar4_growth_forecast <- if (is.list(fc_ar4) && !is.null(fc_ar4$mean)) {
  as.numeric(fc_ar4$mean)
} else {
  as.numeric(fc_ar4)
}

# --- AR(4)–GARCH(1,1) forecast (growth) ---
garch_fc <- ugarchforecast(fit_ar4_garch11, n.ahead = h)
garch_growth_forecast <- as.numeric(garch_fc@forecast$seriesFor)

# --- Convert growth forecasts to fertility levels ---
last_fert <- as.numeric(tail(Fert_ts, 1))

fert_forecast_ar4   <- numeric(h)
fert_forecast_garch <- numeric(h)

for (i in 1:h) {
  if (i == 1) {
    fert_forecast_ar4[i]   <- (1 + ar4_growth_forecast[i]) * last_fert
    fert_forecast_garch[i] <- (1 + garch_growth_forecast[i]) * last_fert
  } else {
    fert_forecast_ar4[i]   <- (1 + ar4_growth_forecast[i]) * fert_forecast_ar4[i - 1]
    fert_forecast_garch[i] <- (1 + garch_growth_forecast[i]) * fert_forecast_garch[i - 1]
  }
}

forecast_years <- max(time(Fert_ts)) + seq_len(h)
```

```{r forecast-table, echo=FALSE}
library(knitr)

h_use <- min(
  length(forecast_years),
  length(ar4_growth_forecast),
  length(garch_growth_forecast),
  length(fert_forecast_ar4),
  length(fert_forecast_garch)
)

forecast_table <- data.frame(
  Year = forecast_years[1:h_use],
  AR4_Growth = round(ar4_growth_forecast[1:h_use], 4),
  GARCH_Growth = round(garch_growth_forecast[1:h_use], 4),
  AR4_Fertility = round(fert_forecast_ar4[1:h_use], 3),
  GARCH_Fertility = round(fert_forecast_garch[1:h_use], 3)
)

kable(
  forecast_table,
  caption = "Table 7: Forecasted Growth and Fertility Rates — AR(4) vs AR(4)–GARCH(1,1) (7-step horizon)"
)


```

```{r fertility-forecast-plot, echo=FALSE, fig.width=6, fig.height=4, fig.align='center',fig.cap="Figure 7: Forecasted fertility rates from AR(4) and AR(4)–GARCH(1,1) models."}
# Make sure both are numeric and same length
fert_forecast_ar4   <- as.numeric(fert_forecast_ar4)
fert_forecast_garch <- as.numeric(fert_forecast_garch)

# Safety: remove NA (if any)
ok <- is.finite(fert_forecast_ar4) & is.finite(fert_forecast_garch)
x  <- forecast_years[ok]
y1 <- fert_forecast_ar4[ok]
y2 <- fert_forecast_garch[ok]

# y-limits based on BOTH series
yl <- range(c(y1, y2), na.rm = TRUE)

# Plot AR(4)
plot(x, y1, type = "l", lwd = 2,
     col = "blue", ylim = yl,
     ylab = "Fertility Rate", xlab = "Year",
     main = "Forecasted Fertility Rates")

# Add GARCH (use different linetype + points so overlap is visible)
lines(x, y2, lwd = 2, col = "red", lty = 2)
points(x, y2, pch = 16, col = "red", cex = 0.6)

legend("topright",
       legend = c("AR(4)", "AR(4)–GARCH(1,1)"),
       col = c("blue", "red"),
       lwd = 2, lty = c(1, 2), bty = "n")
      
```


# Conclusion

This report examined the dynamics of fertility in Saudi Arabia using a time-series framework that jointly models mean behavior and time-varying uncertainty. After establishing non-stationarity in the fertility rate series, the analysis proceeded by modeling fertility growth and identifying an ARIMA(4,1,0) specification as the most appropriate representation of the conditional mean. Diagnostic tests confirmed that the AR(4) structure adequately removed serial correlation from the residuals, but also revealed the presence of significant conditional heteroskedasticity.

To address this limitation, the model was extended to an AR(4)–GARCH(1,1) specification. The GARCH results indicated highly persistent volatility, with the sum of the ARCH and GARCH parameters close to unity, implying that shocks to fertility growth uncertainty decay slowly over time. This finding highlights that fertility dynamics in Saudi Arabia are shaped not only by expected trends but also by prolonged periods of uncertainty, likely reflecting structural transitions in labor markets, housing conditions, and social norms.

Short-run forecasts illustrate the practical importance of accounting for volatility. While the AR(4) model projects declining fertility levels after 2024, the AR(4)–GARCH(1,1) model generates rising fertility paths over the same horizon. This divergence underscores that ignoring time-varying uncertainty can materially alter conclusions about future fertility trajectories, particularly when forecasts are reconstructed in levels. The results therefore caution against reliance on mean-only projections for demographic planning.
